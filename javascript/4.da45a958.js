(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{NCXD:function(e,n,t){"use strict";t("pNMO"),t("4Brf"),t("0oug"),t("ma9I"),t("4mDm"),t("eoL8"),t("5DmW"),t("NBAS"),t("ExoC"),t("07d7"),t("PKPk"),t("SYor"),t("3bBZ"),Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;var l=function(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)if(Object.prototype.hasOwnProperty.call(e,t)){var l=Object.defineProperty&&Object.getOwnPropertyDescriptor?Object.getOwnPropertyDescriptor(e,t):{};l.get||l.set?Object.defineProperty(n,t,l):n[t]=e[t]}return n.default=e,n}(t("q1tI")),o=t("7cJT");function a(e){return(a="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function r(e,n){for(var t=0;t<n.length;t++){var l=n[t];l.enumerable=l.enumerable||!1,l.configurable=!0,"value"in l&&(l.writable=!0),Object.defineProperty(e,l.key,l)}}function u(e){return(u=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function d(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}function i(e,n){return(i=Object.setPrototypeOf||function(e,n){return e.__proto__=n,e})(e,n)}var c=[{key:1,text:"require() 源码解读",to:"http://www.ruanyifeng.com/blog/2015/05/require.html"},{key:2,text:"CommonJS规范",to:"https://javascript.ruanyifeng.com/nodejs/module.html"},{key:3,text:"node-github",to:"https://github.com/nodejs/node/blob/master/lib/internal/modules/cjs/loader.js"},{key:4,text:"nodejs模块源码require问题",to:"https://cnodejs.org/topic/58bcbe8bea21217a4486d01f#58bccc267872ea0864fee3d3"},{key:5,text:"Node.js源码分析之require",to:"https://www.ghosind.com/2019/02/17/require"},{key:6,text:"Node.js v12.9.1 Documentation",to:"https://nodejs.org/api/modules.html"},{key:7,text:"Node.js Require源码粗读",to:"https://juejin.im/post/5ab4d3d151882521d6578298"},{key:8,text:"ECMAScript 6 入门 - Module 的加载实现",to:"https://juejin.im/post/5ab4d3d151882521d6578298"}],m=[{id:1,text:"引言"},{id:2,text:"基础实现"},{id:3,text:"Module 构造函数"},{id:4,text:"加载规则"},{id:5,text:"循环加载"},{id:6,text:"参考资料"}],s="\nconst path = require('padth');\nconst fs = require('fs');\n\nfunction $require(id) {\n  // 获取文件的路径\n  const filename = path.resolve(__dirname, id);\n  const dirname = path.basename(filename);\n  // 读取文件中的内容\n  const oriCode = fs.readFileSync(filename, 'utf8');\n  // 包装代码，营造私有环境\n  const module = { exports: {} };\n  const exports = module.exports;\n  const code = `(function($require, module, exports, __dirname, __filename) {\n    ${oriCode}\n  })($require, module, exports, dirname, filename)`;\n  // 执行代码\n  eval(code);\n  // 暴露对象给外部\n  return module.exports;\n}\n".trim(),f="\nconst path = require('padth');\nconst fs = require('fs');\n\n// 用于缓存\n$require.cache = {};\n\nfunction $require(id) {\n  // 获取文件的路径\n  const filename = path.resolve(__dirname, id);\n  const dirname = path.basename(filename);\n\n  // 先读取缓存，如果存在则直接返回缓存中的 exports 对象\n  if ($require.cache[filename]) {\n    return $require.cache[filename].exports;\n  }\n\n  // 读取文件中的内容\n  const oriCode = fs.readFileSync(filename, 'utf8');\n  // 包装代码，营造私有环境\n  const module = { exports: {} };\n  const exports = module.exports;\n  const code = `(function($require, module, exports, __dirname, __filename) {\n    ${oriCode}\n  })($require, module, exports, dirname, filename)`;\n  // 执行代码\n  eval(code);\n\n  // 第一次执行时，缓存执行的结果\n  $require.cache[filename] = module;\n\n  // 暴露对象给外部\n  return module.exports;\n}\n".trim(),p="\nfunction Module(id, parent) {\n  this.id = id; // 模块的唯一标识符，通常为其绝对路径\n  this.exports = {}; // 暴露给外部的对象\n  this.parent = parent; // 调用该模块的模块\n  this.filename = null; // 模块的绝对路径\n  this.loaded = false; // 当前模块是否加载完成\n  this.children = []; // 调用的模块\n}\n\nModule._cache = Object.create(null);\n".trim(),E="\n// Loads a module at the given file path. Returns that module's `exports` property.\nModule.prototype.require = function() {\n  // ...\n  return Module._load(id, this, /* isMain */ false);\n};\n".trim(),h="\n// Check the cache for the requested file.\nModule._load = function(request, parent, isMain) {\n //...\n // 计算文件的绝对路径\n const filename = Module._resolveFilename(request, parent, isMain);\n\n // 判断缓存中是否存在该模块，如果存在直接返回\n const cachedModule = Module._cache[filename];\n if (cachedModule !== undefined) {\n   return cachedModule.exports;\n }\n\n // 处理内置模块\n const mod = loadNativeModule(filename, request, experimentalModules);\n if (mod && mod.canBeRequiredByUsers) return mod.exports;\n\n // 生成模块实例，加入缓存\n const module = new Module(filename, parent);\n Module._cache[filename] = module;\n\n // 加载模块\n module.load(filename);\n\n // 输出模块的 exports 属性\n return module.exports;\n};\n".trim(),b="\n// Given a file name, pass it to the proper extension handler.\nModule.prototype.load = function(filename) {\n  this.filename = filename;\n  this.paths = Module._nodeModulePaths(path.dirname(filename));\n\n  // 获取扩展名，调用对应的加载方法\n  const extension = findLongestRegisteredExtension(filename);\n  Module._extensions[extension](this, filename);\n  this.loaded = true;\n  // ...\n};\n".trim(),x="\n// Native extension for .js\nModule._extensions['.js'] = function(module, filename) {\n  const content = fs.readFileSync(filename, 'utf8');\n  module._compile(content, filename);\n};\n".trim(),j="\nModule.wrap = function(script) {\n  return Module.wrapper[0] + script + Module.wrapper[1];\n};\n\nModule.wrapper = [\n  '(function (exports, require, module, __filename, __dirname) { ',\n  '\n});',\n];\n\nModule.prototype._compile = function(content, filename) {\n  content = stripShebang(content);\n\n  var wrapper = Module.wrap(content);\n\n  var compiledWrapper = vm.runInThisContext(wrapper, {\n    filename: filename,\n    lineOffset: 0,\n    displayErrors: true,\n  });\n\n  // ...\n};\n".trim(),y='\n（1）如果 X 是内置模块。\n    a. 直接返回该模块；\n    b. 停止。\n\n（2）如果 X 是以 / 开头的，则将 Y 设置为文件系统根目录。\n\n（3）如果 X 是以 ./ 或 / 或 ../ 开头。\n    a. 根据 Y 和 X 拼接为绝对路径（Y + X）；\n    b. 将 X 当成文件，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行；\n        1. 如果 X 是一个文件，则加载该文件的内容作为 JavaScript 文本返回。\n        2. 如果 X.js 是一个文件，则加载该文件的内容作为 JavaScript 文本返回。\n        3. 如果 X.json 是一个文件，则加载该文件的内容并解析为 JavaScript 对象返回。\n        4. 如果 X.node 是一个文件则作为 binary addon 进行加载。\n    c. 将 X 当成目录，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行；\n        1. 如果 X 目录下存在 package.json 文件，则读取该文件中 main 字段的值，根据 X+main 的新路径当作文件重复上一个步骤 b 进行查找，\n           如果不存在则以此按下所示进行加载。\n            i. 如果 X+main/index.js 是一个文件，则加载该文件的内容作为 JavaScript 文本返回。\n            ii. 如果 X+main/index.json 是一个文件，则加载该文件的内容并解析为 JavaScript 对象返回。\n            iii. 如果 X+main/index.node 是一个文件则作为 binary addon 进行加载。\n        2. 如果上述步骤还未找到，则进行以下步骤。\n            i. 如果 X/index.js 是一个文件，则加载该文件的内容作为 JavaScript 文本返回。\n            ii. 如果 X/index.json 是一个文件，则加载该文件的内容并解析为 JavaScript 对象返回。\n            iii. 如果 X/index.node 是一个文件则作为 binary addon 进行加载。\n\n（4）如果 X 不带路径。\n    a. 根据 X 所在的父模块，依次往根目录确定 X 可能的安装目录。 \n    b. 依次在每个目录下的 node_modules 目录下，将 X 当成文件名或目录名加载。\n\n（5）抛出 "not found"。\n'.trim(),g="\n// a.js\nconsole.log('a starting');\nexports.done = false;\nconst b = require('./b.js');\nconsole.log('in a, b.done = %j', b.done);\nexports.done = true;\nconsole.log('a done');\n\n// b.js\nconsole.log('b starting');\nexports.done = false;\nconst a = require('./a.js');\nconsole.log('in b, a.done = %j', a.done);\nexports.done = true;\nconsole.log('b done');\n\n// main.js\nconsole.log('main starting');\nconst a = require('./a.js');\nconst b = require('./b.js');\nconsole.log('in main, a.done = %j, b.done = %j', a.done, b.done);\n\n$ node main.js\nmain starting\na starting\nb starting\nin b, a.done = false\nb done\nin a, b.done = true\na done\nin main, a.done = true, b.done = true\n".trim(),q="\n// 生成模块实例，加入缓存\n const module = new Module(filename, parent);\n Module._cache[filename] = module;\n\n // 加载模块\n module.load(filename);\n".trim(),M=function(e){function n(){var e,t,l,o,r,i,c;!function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,n);for(var m=arguments.length,s=new Array(m),f=0;f<m;f++)s[f]=arguments[f];return l=this,t=!(o=(e=u(n)).call.apply(e,[this].concat(s)))||"object"!==a(o)&&"function"!=typeof o?d(l):o,r=d(t),c={takeTime:0},(i="state")in r?Object.defineProperty(r,i,{value:c,enumerable:!0,configurable:!0,writable:!0}):r[i]=c,t}var t,M,v;return function(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),n&&i(e,n)}(n,l.PureComponent),t=n,(M=[{key:"componentDidMount",value:function(){var e=0,n=document.querySelector("#bowen");if(n){var t=n.innerText||"";e=Math.round(t.length/280)}this.setState(function(){return{takeTime:e}})}},{key:"render",value:function(){var e="理清 Nodejs 中的 require 函数",n=this.state.takeTime,t=this.props.birthTime;return l.default.createElement(o.Bowen,{tocs:m},l.default.createElement(o.Counter,{showTime:!0,time:t,showTakeTime:!0,takeTime:n,title:e}),l.default.createElement(o.Bowen.Header,{title:e,description:"Nodejs 遵循 CommonJS 规范，通过内置的 require 函数加载各个模块，因此理解 require 函数的实现对学习 Nodejs 至关重要。"}),l.default.createElement(o.Bowen.Content,null,l.default.createElement(o.Bowen.Title,{id:"CusTomNodeRequire-1",text:"引言"}),l.default.createElement("p",null,"在 ES6 出现之前 ",l.default.createElement("code",null,"JavaScript")," ","本身并没有模块的概念，不支持封闭的作用域和依赖管理，这对于开发大型项目来说十分头疼。所以，社区制定了一些模块加载方案来解决这个问题，其中就包括 CommonJS 规范，在此规范中每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。2009 年，",l.default.createElement("code",null,"Nodejs")," 项目诞生，所有模块一律采用 CommonJS 规范，并通过内置的"," ",l.default.createElement("code",null,"require")," 函数来加载模块文件。"),l.default.createElement("p",null,"对于前端开发的同学，对于 ",l.default.createElement("code",null,"require")," ","这个函数肯定不会陌生，它的基本功能就是，读取并执行一个 ",l.default.createElement("code",null,"JavaScript")," ","文件，然后返回该模块的 ",l.default.createElement("code",null,"exports")," ","对象。如果没有发现指定模块，会报错。下面先简单的列举一下它的工作流程。"),l.default.createElement("ul",{className:"decimal"},l.default.createElement("li",null,"接受一个类型为字符串的参数，根据该参数查找文件，如果未找到将会报错。"),l.default.createElement("li",null,"读取文件，并返回文件中的代码。"),l.default.createElement("li",null,"处理并执行代码。"),l.default.createElement("li",null,"模块的 ",l.default.createElement("code",null,"exports")," 对象。")),l.default.createElement(o.Bowen.Title,{id:"CusTomNodeRequire-2",text:"基础实现"}),l.default.createElement("p",null,"根据上面总结的步骤我们很容易写出下面的代码。"),l.default.createElement(o.SyntaxHighlighter,null,s),l.default.createElement("p",null,"根据平时使用的经验，Nodejs"," ","会对加载的结果进行一次缓存，再次加载时就会得到缓存中的结果，接下来简单的实现一下这个功能。"),l.default.createElement("p",null,"在 ",l.default.createElement("code",null,"$require")," ","对象上首先声明一个空对象用来进行缓存，在加载模块时同样先获取请求模块的绝对路径，然后判读缓存中是否包含此模块，有则直接返回缓存中该模块暴露的"," ",l.default.createElement("code",null,"exports")," 对象，否则继续执行，最后把执行结果，也就是 ",l.default.createElement("code",null,"module")," ","对象，以绝对路径为 ",l.default.createElement("code",null,"key")," 存储起来。"),l.default.createElement(o.SyntaxHighlighter,null,f),l.default.createElement("p",null,"这个 ",l.default.createElement("code",null,"$require")," 函数的实现特别简单，但却能很好的描述 Nodejs 中"," ",l.default.createElement("code",null,"require")," 函数的基本原理。"),l.default.createElement(o.Bowen.Title,{id:"CusTomNodeRequire-3",text:"Module 构造函数"}),l.default.createElement("p",null,"Nodejs 定义了一个构造函数 Module，所有的模块都是 Module 的实例。"),l.default.createElement(o.SyntaxHighlighter,null,p),l.default.createElement("p",null,"每个模块实例都有一个 ",l.default.createElement("code",null,"require")," 方法，定义在 Module 对象的原型上面，因此除了"," ","REPL 环境外，只有在模块内部才能使用 ",l.default.createElement("code",null,"require")," ","方法，该方法的关键就在于内部调用了 Module 对象上的 ",l.default.createElement("code",null,"_load")," 方法。"),l.default.createElement(o.SyntaxHighlighter,null,E),l.default.createElement("p",null,"Module 模块的 ",l.default.createElement("code",null,"_load")," ","方法的主要检查缓存中是否已经存在该模块，若已存在则直接从缓存中获取；否则，则判断该模块是否为 Native 模块，当模块为 Native 模块时，调用 ",l.default.createElement("code",null,"NativeModule.require")," ","进行方法加载，如果不是将创建一个新的 Module 实例，然后将其加入到缓存中，并调用 Module 模块的 ",l.default.createElement("code",null,"load")," 方法加载模块，并根据是否存在错误进行相应的处理。"),l.default.createElement("p",null,"简化示意的 ",l.default.createElement("code",null,"_load")," 函数如下所示。"),l.default.createElement(o.SyntaxHighlighter,null,h),l.default.createElement("p",null,"Module 模块的 ",l.default.createElement("code",null,"load")," ","方法主要根据需要加载的文件的扩展名判断并选取对应的加载方法，除此以外它还包括了部分实验性模块的处理。"),l.default.createElement(o.SyntaxHighlighter,null,b),l.default.createElement("p",null,"文件的加载方法存放在 Module 模块的 ",l.default.createElement("code",null,"_extensions")," 属性中，在该文件中主要定义了"," ",l.default.createElement("code",null,".js"),"，",l.default.createElement("code",null,".json"),"，",l.default.createElement("code",null,".node"),"，",l.default.createElement("code",null,".mjs")," ","四种文件的加载方法。",l.default.createElement("code",null,".js")," 与 ",l.default.createElement("code",null,".json")," 文件的加载皆为调用 ",l.default.createElement("code",null,"fs")," 模块的"," ",l.default.createElement("code",null,"readFileSync")," 方法读取文件内容后进行对应的处理，而对于 ",l.default.createElement("code",null,".node")," ","文件，则使用了 ",l.default.createElement("code",null,"process")," 的 ",l.default.createElement("code",null,"dlopen")," 方法加载 C++ 扩展。"),l.default.createElement("p",null,"以对 JavaScript 文件的处理为例，简化示意如下所示。"),l.default.createElement(o.SyntaxHighlighter,null,x),l.default.createElement("p",null,"在加载 JavaScript 文件时，读取文件内容后将调用 Module 模块的 ",l.default.createElement("code",null,"_compile")," ","方法，对读取到的文件内容进行一定的处理。"),l.default.createElement(o.SyntaxHighlighter,null,j),l.default.createElement("p",null,"在这个方法中的处理，主要就像我们一开始创建的简易版的 ",l.default.createElement("code",null,"$require")," ","函数一样。提供相应的变量给文件中的代码，然后置于正确的作用域下执行，如果出现异常则抛出异常。"),l.default.createElement("p",null,"至此，便完成了使用 ",l.default.createElement("code",null,"require")," ","加载模块的过程，其主要内容就是在判断缓存后读取文件内容，然后使用 VM 模块运行。"),l.default.createElement(o.Bowen.Title,{id:"CusTomNodeRequire-4",text:"加载规则"}),l.default.createElement("p",null,"当在 Y 路径下通过 require(X) 加载模块时，会经过以下处理步骤。"),l.default.createElement(o.SyntaxHighlighter,null,y),l.default.createElement(o.Bowen.Title,{id:"CusTomNodeRequire-5",text:"循环加载"}),l.default.createElement("p",null,"通常，“循环加载”表示存在强耦合，比如在模块 A 中依赖模块 B 中的内容，而 B 又需要 A"," ","中的结果。如果处理不好，还可能导致递归加载，使得程序无法执行，因此应该避免出现。"),l.default.createElement("p",null,"然而，在大型项目中这中情况很难避免，CommonJS 模块的重要特性是加载时执行，即脚本代码通过"," ",l.default.createElement("code",null,"require")," ",'加载的时候，就会全部执行。一旦出现某个模块被"循环加载"，就只输出已经执行的部分，还未执行的部分不会输出。'),l.default.createElement("p",null,"接下来看一下官方的例子。"),l.default.createElement(o.SyntaxHighlighter,null,g),l.default.createElement("p",null,"当执行到 ",l.default.createElement("code",null,"a.js")," 时，会先暴露出 ",l.default.createElement("code",null,"done")," 变量，然后去加载"," ",l.default.createElement("code",null,"b.js"),"，并将执行权交给 ",l.default.createElement("code",null,"b.js"),"。当 ",l.default.createElement("code",null,"b.js")," ","执行到第二行时就会去请求 ",l.default.createElement("code",null,"a.js"),"。但是此时不会将执行权交换，而是去缓存中读取"," ",l.default.createElement("code",null,"a.js")," 对应对象的 ",l.default.createElement("code",null,"exports")," 属性取值。"),l.default.createElement("p",null,"虽然 ",l.default.createElement("code",null,"a.js")," 还未执行完，但是在加载完 ",l.default.createElement("code",null,"a.js")," ","之前，其实已经将其对应的 ",l.default.createElement("code",null,"module")," 对象保存在缓存中，可见上面分析的"," ",l.default.createElement("code",null,"Module._load")," 方法。"),l.default.createElement(o.SyntaxHighlighter,null,q),l.default.createElement("p",null,"因此，结果会是先执行完 ",l.default.createElement("code",null,"b.js"),"，然后再执行完 ",l.default.createElement("code",null,"a.js"),"，最后执行完"," ",l.default.createElement("code",null,"main.js"),"。由此可见 CommonJS 模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，加上 CommonJS 输入的是被输出值的拷贝，不是引用，所以前后同一者可能会有差异。"),l.default.createElement(o.Bowen.Title,{id:"CusTomNodeRequire-6",text:"参考资料"}),l.default.createElement(o.Bowen.Reference,{refs:c})),l.default.createElement(o.Comment,null),l.default.createElement(o.Bowen.Footer,null))}}])&&r(t.prototype,M),v&&r(t,v),n}();n.default=M}}]);